<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LZ78 学習アプリ（シンプル＋ビット列表示＋グラフアニメ）</title>
<style>
:root{
  --bg:#0b1020;
  --panel:#111a33;
  --panel2:#0f1730;
  --text:#e8ecff;
  --muted:#aeb7e6;
  --border:#24315e;
  --accent:#7aa2ff;
  --accent2:#7dffb2;
  --danger:#ff6b6b;
  --shadow:0 18px 50px rgba(0,0,0,.35);
  --radius:12px;
  --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
  --sans:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,
         "Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;
}
*{box-sizing:border-box;}
html,body{height:100%;}
body{
  margin:0;
  background:
    radial-gradient(1200px 600px at 10% -10%,rgba(122,162,255,.28),transparent 60%),
    radial-gradient(900px 600px at 110% 10%,rgba(125,255,178,.14),transparent 55%),
    var(--bg);
  color:var(--text);
  font-family:var(--sans);
}
header{
  padding:14px 18px 8px;
  display:flex;
  gap:12px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}
h1{margin:0;font-size:18px;}
small{color:var(--muted);}
.container{
  padding:10px 18px 18px;
  display:grid;
  grid-template-columns:1.1fr 1fr;
  gap:12px;
}
@media (max-width:1000px){.container{grid-template-columns:1fr;}}
.card{
  background:linear-gradient(180deg,rgba(255,255,255,.03),transparent 30%),var(--panel);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;
}
.card .hd{
  padding:8px 12px;
  border-bottom:1px solid rgba(36,49,94,.85);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  flex-wrap:wrap;
}
.card .bd{padding:10px 12px;}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
label{
  font-size:12px;
  color:var(--muted);
  display:flex;
  gap:4px;
  align-items:center;
}
input[type=text],input[type=number],textarea,select{
  background:var(--panel2);
  color:var(--text);
  border:1px solid rgba(36,49,94,.9);
  border-radius:9px;
  padding:6px 8px;
  font-family:var(--mono);
  font-size:13px;
}
select{height:28px; padding:0 8px;}
input[type=text],input[type=number]{height:28px;}
textarea{
  width:100%;
  min-height:68px;
  resize:vertical;
}
button{
  height:28px;
  padding:0 9px;
  border-radius:9px;
  border:1px solid rgba(36,49,94,.95);
  background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
  color:var(--text);
  cursor:pointer;
  font-size:13px;
}
button:hover{border-color:rgba(122,162,255,.55);}
button:active{transform:translateY(1px);}
button.primary{
  border-color:rgba(122,162,255,.55);
  background:linear-gradient(180deg,rgba(122,162,255,.25),rgba(122,162,255,.10));
}
button.good{
  border-color:rgba(125,255,178,.55);
  background:linear-gradient(180deg,rgba(125,255,178,.22),rgba(125,255,178,.08));
}
button.danger{
  border-color:rgba(255,107,107,.55);
  background:linear-gradient(180deg,rgba(255,107,107,.18),rgba(255,107,107,.06));
}
button.ghost{background:transparent;}
.pill{
  font-family:var(--mono);
  font-size:11px;
  padding:3px 7px;
  border-radius:999px;
  border:1px solid rgba(36,49,94,.9);
  background:rgba(15,23,48,.95);
  color:var(--muted);
}
hr.sep{border:none;border-top:1px solid rgba(36,49,94,.75);margin:8px 0;}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
@media (max-width:700px){.grid2{grid-template-columns:1fr;}}
.tableWrap{
  margin-top:6px;
  overflow:auto;
  border:1px solid rgba(36,49,94,.85);
  border-radius:9px;
  background:rgba(15,23,48,.55);
}
table{
  width:100%;
  border-collapse:collapse;
  font-family:var(--mono);
  font-size:12px;
}
th,td{
  padding:6px 8px;
  border-bottom:1px solid rgba(36,49,94,.6);
  vertical-align:top;
}
th{
  text-align:left;
  position:sticky;
  top:0;
  background:rgba(17,26,51,.95);
  color:var(--muted);
}
tr:last-child td{border-bottom:none;}
tr.active{
  outline:2px solid rgba(122,162,255,.5);
  outline-offset:-2px;
  background:rgba(122,162,255,.08);
}
.note{font-size:12px;color:var(--muted);line-height:1.5;}
.kbd{
  font-family:var(--mono);
  font-size:11px;
  padding:1px 5px;
  border-radius:7px;
  border:1px solid rgba(36,49,94,.95);
  background:rgba(15,23,48,.9);
  color:var(--text);
}

/* 右側 */
.rightSplit{
  display:grid;
  grid-template-rows:auto 1fr;
  height:70vh;
  min-height:420px;
}
@media (max-width:1000px){.rightSplit{height:auto;min-height:unset;}}
.rightBody{
  padding:8px 10px;
  height:100%;
  display:grid;
  grid-template-rows:1.2fr 0.8fr;
  gap:8px;
}
.graphWrap{
  height:100%;
  min-height:260px;
  overflow:auto;
  border:1px solid rgba(36,49,94,.85);
  border-radius:9px;
  background:rgba(15,23,48,.45);
}
#graph{display:block;}
svg{display:block;}
.node circle{
  fill:rgba(122,162,255,.12);
  stroke:rgba(122,162,255,.85);
  stroke-width:1.5;
}
.node text{
  fill:var(--text);
  font-family:var(--mono);
  font-size:11px;
}
.edge{
  stroke:rgba(174,183,230,.6);
  stroke-width:1.2;
}
.edgeLabel{
  font-family:var(--mono);
  font-size:11px;
  fill:rgba(232,236,255,.9);
  paint-order:stroke;
  stroke:rgba(11,16,32,.9);
  stroke-width:4px;
}
.node.hl-path circle{fill:rgba(122,162,255,.25);stroke:rgba(122,162,255,1);stroke-width:2;}
.node.hl-new  circle{fill:rgba(125,255,178,.25);stroke:rgba(125,255,178,1);stroke-width:2;}
.node.hl-ref  circle{fill:rgba(255,209,102,.25);stroke:rgba(255,209,102,1);stroke-width:2;}
.node.hl-sel  circle{fill:rgba(255,107,107,.2);stroke:rgba(255,107,107,1);stroke-width:2;}
#dictTable tr.d-row:hover{background:rgba(255,255,255,.04);cursor:pointer;}
#dictTable tr.d-path{background:rgba(122,162,255,.08);}
#dictTable tr.d-new{background:rgba(125,255,178,.08);}
#dictTable tr.d-ref{background:rgba(255,209,102,.08);}
#dictTable tr.d-sel{outline:2px solid rgba(255,107,107,.5);outline-offset:-2px;}

.toast{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  background:rgba(15,23,48,.95);
  border:1px solid rgba(36,49,94,.9);
  border-radius:9px;
  padding:6px 10px;
  box-shadow:var(--shadow);
  color:var(--text);
  font-size:12px;
  display:none;
}
.toast.show{display:block;}
</style>
</head>
<body>
<header>
  <div>
    <h1>LZ78 学習アプリ（シンプル＋ビット列＋グラフアニメ）</h1>
    <small>ステップ実行時に、辞書木へのノード追加が滑らかにアニメーションします。</small>
  </div>
  <div class="row">
    <span class="pill" id="statusPill">準備OK</span>
    <button class="ghost" id="btnClearAll">全リセット</button>
  </div>
</header>

<div class="container">
  <section class="card">
    <div class="hd">
      <div class="row">
        <strong>操作</strong>
        <span class="pill">記号は 1 文字（a,b,c,...）想定</span>
      </div>
      <div class="row">
        <button class="primary" id="btnEncodeAll">符号化（全部）</button>
        <button id="btnEncodeStep">符号化（ステップ開始）</button>
        <button id="btnDecodeAll">復号（全部）</button>
        <button id="btnDecodeStep">復号（ステップ開始）</button>
        <button id="btnNext" class="good" disabled>次へ</button>
        <button id="btnReset" class="danger" disabled>現在モードをリセット</button>
      </div>
    </div>

    <div class="bd">
      <div class="grid2">
        <div>
          <div class="row" style="justify-content:space-between;">
            <label>入力（記号列） <span class="kbd">例: ababbababaa</span></label>
            <div class="row">
              <button id="btnExample">例を再入力</button>
              <button class="good" id="btnRandom">ランダム</button>
            </div>
          </div>
          <textarea id="inputText">ababbababaa</textarea>
          <div class="row" style="margin-top:6px;">
            <label>アルファベット Σ
              <input type="text" id="alphabet" value="ab" style="width:90px;">
            </label>
            <label>ランダム長
              <input type="number" id="randLen" value="24" min="1" max="400" style="width:70px;">
            </label>
          </div>
          <div class="note" id="parseInfo" style="margin-top:4px;"></div>
        </div>

        <div>
          <div class="row" style="justify-content:space-between;">
            <label>符号語列（復号入力） <span class="kbd">例: 0,a | 0,b | ...</span></label>
            <button id="btnCopyTokens">コピー</button>
          </div>
          <textarea id="tokensText" spellcheck="false"></textarea>

          <div class="row" style="margin-top:6px;justify-content:space-between;">
            <label>符号語（ビット列表示）</label>
            <div class="row">
              <label>表示形式
                <select id="bitsStyle">
                  <option value="lecture">講義資料風（区切りあり）</option>
                  <option value="concat">連結（区切り無し）</option>
                </select>
              </label>
              <button id="btnCopyBits">コピー</button>
            </div>
          </div>
          <textarea id="bitsText" readonly></textarea>

          <div class="row" style="margin-top:6px;">
            <label>復号結果 <span class="kbd">readonly</span></label>
          </div>
          <textarea id="decodedText" readonly></textarea>
        </div>
      </div>

      <hr class="sep">

      <div class="row" style="justify-content:space-between;">
        <div>
          <strong id="logTitle">ログ（符号化）</strong>
          <div class="note" id="logNote">
            LZ78: 最長一致 w と次の記号 c から (i,c) を出力し、辞書に wc を追加します。
          </div>
        </div>
        <div class="row">
          <span class="pill" id="stepInfo">step: -</span>
          <span class="pill" id="dictInfo">辞書サイズ: 1</span>
        </div>
      </div>

      <div class="tableWrap">
        <table id="logTable">
          <thead><tr id="logHeadRow"></tr></thead>
          <tbody id="logBody">
            <tr><td colspan="7" class="note">まだ何も実行していません。</td></tr>
          </tbody>
        </table>
      </div>

      <div class="note" style="margin-top:6px;">
        ショートカット:
        <span class="kbd">Ctrl/⌘ + Enter</span> で一括実行 /
        <span class="kbd">Ctrl/⌘ + Space</span> で「次へ」。
      </div>
    </div>
  </section>

  <section class="card rightSplit">
    <div class="hd">
      <div class="row">
        <strong>辞書（木 + 表）</strong>
        <span class="pill">root = 0（空列）</span>
      </div>
      <div class="row">
        <button id="btnFit">フィット</button>
        <button id="btnExportSvg">SVG</button>
        <button id="btnExportDict">CSV</button>
      </div>
    </div>

    <div class="rightBody">
      <div>
        <div class="row" style="justify-content:space-between;margin-bottom:4px;">
          <span class="note">辞書木（ステップ時にアニメします / スクロールで全体確認）</span>
          <span class="pill" id="selInfo">選択: -</span>
        </div>
        <div class="graphWrap">
          <svg id="graph"></svg>
        </div>
      </div>

      <div>
        <div class="row" style="justify-content:space-between;margin-bottom:4px;">
          <span class="note">辞書表（番号 → 語）</span>
          <div class="row">
            <label>検索
              <input type="text" id="dictSearch" style="width:150px;">
            </label>
            <button id="btnClearSel" class="ghost">選択解除</button>
          </div>
        </div>
        <div class="graphWrap">
          <table id="dictTable">
            <thead>
            <tr>
              <th style="width:60px;">id</th>
              <th style="width:60px;">親</th>
              <th style="width:90px;">枝ラベル</th>
              <th>語（phrase）</th>
            </tr>
            </thead>
            <tbody id="dictBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </section>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const el = (tag,attrs={})=>{
    const n=document.createElement(tag);
    for(const [k,v] of Object.entries(attrs)){
      if(k==="class") n.className=v;
      else if(k==="text") n.textContent=v;
      else n.setAttribute(k,v);
    }
    return n;
  };

  const toast=(msg,kind="info")=>{
    const t=$("#toast");
    t.textContent=msg;
    t.style.borderColor=
      kind==="danger"?"rgba(255,107,107,.6)":
      kind==="good"  ?"rgba(125,255,178,.6)":
                      "rgba(122,162,255,.6)";
    t.classList.add("show");
    clearTimeout(toast._timer);
    toast._timer=setTimeout(()=>t.classList.remove("show"),2000);
  };

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const trunc=(s,max=6)=>{
    const a=Array.from(s);
    return a.length<=max?s:a.slice(0,Math.max(1,max-1)).join("")+"…";
  };
  const ceilLog2=n=>n<=1?0:Math.ceil(Math.log2(n));
  const toBin=(n,b)=>b<=0?"":(n>>>0).toString(2).padStart(b,"0");
  const charToBits = ch => ch.codePointAt(0).toString(2).padStart(8,"0"); // ASCII 想定

  const parseAlphabet = raw=>{
    const s=(raw??"").trim();
    if(!s) return [];
    return Array.from(s);
  };
  const parseInputSymbols = (raw,alphabet)=>{
    const s=(raw??"").replace(/\s+/g,"");
    if(!s) return [];
    if(alphabet.length){
      for(const ch of s){
        if(!alphabet.includes(ch)){
          throw new Error(`入力中の記号 "${ch}" が Σ に含まれていません`);
        }
      }
    }
    return Array.from(s);
  };

  const parseTokens = txt=>{
    const raw=(txt??"").trim();
    if(!raw) return [];
    const parts=raw.split(/[|\n\r]+/).map(x=>x.trim()).filter(Boolean);
    const toks=[];
    for(const p0 of parts){
      let p=p0.trim();
      if(p.startsWith("(")&&p.endsWith(")")) p=p.slice(1,-1).trim();
      const sp=p.split(",").map(x=>x.trim());
      if(sp.length===1){
        if(!/^[0-9]+$/.test(sp[0])) throw new Error(`参照番号が不正: "${sp[0]}"`);
        toks.push({index:Number(sp[0]),next:null});
      }else if(sp.length===2){
        if(!/^[0-9]+$/.test(sp[0])) throw new Error(`参照番号が不正: "${sp[0]}"`);
        const idx=Number(sp[0]);
        const c=sp[1];
        if(c.length!==1) throw new Error(`next 記号は 1 文字のみ対応です: "${c}"`);
        toks.push({index:idx,next:c});
      }else{
        throw new Error(`トークン形式が不正です: "${p0}"`);
      }
    }
    return toks;
  };

  const formatTokens = toks =>
    toks.map(t => t.next==null ? `${t.index}` : `${t.index},${t.next}`).join(" | ");

  const tokenBitsText = (tokens, style)=>{
    const pieces=[];
    for(let j=1;j<=tokens.length;j++){
      const t=tokens[j-1];
      const L=ceilLog2(j);
      const iBits=L?toBin(t.index,L):"";
      const cBits=t.next==null?"":charToBits(t.next);
      const outBits=iBits+cBits;
      if(style==="concat"){
        pieces.push(outBits);
      }else{
        if(t.next==null) pieces.push(iBits||"");
        else pieces.push(iBits?`${iBits},${cBits}`:cBits);
      }
    }
    return style==="concat" ? pieces.join("") : pieces.join(" | ");
  };

  const updateBitsView = ()=>{
    const style=$("#bitsStyle").value;
    let tokens;
    try{ tokens=parseTokens($("#tokensText").value); }
    catch{ $("#bitsText").value=""; return; }
    $("#bitsText").value = tokens.length ? tokenBitsText(tokens, style) : "";
  };

  // 辞書（トライ）
  const newDict = ()=>({nodes:[{id:0,parent:null,sym:"",phrase:"",children:new Map()}]});
  const dictAdd = (dict,parentId,sym)=>{
    const p=dict.nodes[parentId];
    if(!p) throw new Error("parent not found:"+parentId);
    if(p.children.has(sym)) return p.children.get(sym);
    const id=dict.nodes.length;
    const node={id,parent:parentId,sym,phrase:p.phrase+sym,children:new Map()};
    dict.nodes.push(node);
    p.children.set(sym,id);
    return id;
  };
  const pathToRoot = (dict,id)=>{
    const arr=[]; let cur=id;
    while(cur!=null){arr.push(cur);cur=dict.nodes[cur].parent;}
    return arr.reverse();
  };

  const app={
    mode:"idle",
    enc:null,
    dec:null,
    visual:{dict:newDict(),hl:{pathIds:[],newId:null,refId:null,selId:null}}
  };

  const setStatus=s=>$("#statusPill").textContent=s;
  const setMode=m=>{
    app.mode=m;
    $("#logTitle").textContent=m==="decode"?"ログ（復号）":"ログ（符号化）";
    $("#logNote").textContent=
      m==="decode"
      ?"復号: (i,c) から語 w を参照し wc を出力し、辞書に wc を登録します。"
      :"符号化: 最長一致 w と次の記号 c から (i,c) を出力し、辞書に wc を追加します。";
  };
  const setControls=({nextEnabled,resetEnabled})=>{
    $("#btnNext").disabled=!nextEnabled;
    $("#btnReset").disabled=!resetEnabled;
  };
  const updateMeta=({step,dictSize})=>{
    $("#stepInfo").textContent="step: "+(step??"-");
    $("#dictInfo").textContent="辞書サイズ: "+(dictSize??1);
  };

  const currentAlphabet = ()=>parseAlphabet($("#alphabet").value);
  const currentInput = ()=>{
    const A=currentAlphabet();
    return parseInputSymbols($("#inputText").value,A);
  };
  const renderParseInfo = ()=>{
    try{
      const A=currentAlphabet();
      const X=currentInput();
      $("#parseInfo").textContent=`Σ(${A.length})={ ${A.join(", ")} } / 入力長=${X.length}`;
    }catch(e){
      $("#parseInfo").textContent="⚠ "+e.message;
    }
  };

  // ===== グラフ（SVG）: 増分更新 + アニメ =====
  const SVG_NS="http://www.w3.org/2000/svg";
  const svgElNS = (tag,attrs={})=>{
    const n=document.createElementNS(SVG_NS,tag);
    for(const [k,v] of Object.entries(attrs)) n.setAttribute(k,v);
    return n;
  };

  const graphUI={
    svg:null,
    gEdges:null,
    gNodes:null,
    nodeEls:new Map(),
    edgeEls:new Map(),   // childId -> line
    labelEls:new Map(),  // childId -> text
    posX:[],
    posY:[],
    lastDictSize:0,
    raf:0,
    animActive:false
  };

  const EASE = t => 1 - Math.pow(1 - t, 3); // easeOutCubic
  const ANIM_MS = 280;

  const cancelGraphAnim = ()=>{
    if(graphUI.raf) cancelAnimationFrame(graphUI.raf);
    graphUI.raf=0;
    graphUI.animActive=false;
  };

  const hardResetGraph = ()=>{
    cancelGraphAnim();
    if(!graphUI.svg) return;
    while(graphUI.svg.firstChild) graphUI.svg.removeChild(graphUI.svg.firstChild);
    graphUI.gEdges=null;
    graphUI.gNodes=null;
    graphUI.nodeEls.clear();
    graphUI.edgeEls.clear();
    graphUI.labelEls.clear();
    graphUI.posX=[];
    graphUI.posY=[];
    graphUI.lastDictSize=0;
  };

  const ensureGraphGroups = ()=>{
    if(graphUI.gEdges && graphUI.gNodes) return;
    const gE=svgElNS("g",{id:"edges"});
    const gN=svgElNS("g",{id:"nodes"});
    graphUI.svg.appendChild(gE);
    graphUI.svg.appendChild(gN);
    graphUI.gEdges=gE;
    graphUI.gNodes=gN;
  };

  const buildChildren = dict=>{
    const children=Array.from({length:dict.nodes.length},()=>[]);
    for(const n of dict.nodes) if(n.parent!=null) children[n.parent].push(n.id);
    for(const arr of children){
      arr.sort((a,b)=>{
        const sa=dict.nodes[a].sym, sb=dict.nodes[b].sym;
        return sa<sb?-1:sa>sb?1:a-b;
      });
    }
    return children;
  };

  const computeLayout = (dict,gx=90,gy=70)=>{
    const children=buildChildren(dict);
    const depth=new Array(dict.nodes.length).fill(0);
    let maxD=0;
    for(let i=1;i<dict.nodes.length;i++){
      const p=dict.nodes[i].parent;
      depth[i]=depth[p]+1;
      if(depth[i]>maxD) maxD=depth[i];
    }
    let leaf=0;
    const xIndex=new Array(dict.nodes.length).fill(0);
    const rec=id=>{
      const kids=children[id];
      if(!kids || !kids.length){xIndex[id]=leaf++;return;}
      for(const k of kids) rec(k);
      const mn=Math.min(...kids.map(k=>xIndex[k]));
      const mx=Math.max(...kids.map(k=>xIndex[k]));
      xIndex[id]=(mn+mx)/2;
    };
    rec(0);
    const leafCount=Math.max(leaf,1);
    const width=Math.max(600,(leafCount-1)*gx+160);
    const height=Math.max(400,maxD*gy+140);
    const marginX=60, marginY=40;
    const scaleX=(leafCount===1)?0:(width-2*marginX)/(leafCount-1);
    const pos=xIndex.map((xi,id)=>({
      x:marginX+(leafCount===1?(width-2*marginX)/2:xi*scaleX),
      y:marginY+depth[id]*gy
    }));
    return {pos,width,height};
  };

  function nodeClass(id, hl){
    const pathSet = new Set(hl.pathIds||[]);
    let cls="node";
    if(pathSet.has(id)) cls+=" hl-path";
    if(hl.newId===id) cls+=" hl-new";
    if(hl.refId===id) cls+=" hl-ref";
    if(hl.selId===id) cls+=" hl-sel";
    return cls;
  }

  function setSelection(id){
    if(!app.visual.dict || !app.visual.dict.nodes[id]) return;
    app.visual.hl.selId=id;
    const n=app.visual.dict.nodes[id];
    $("#selInfo").textContent=id===0?"選択: 0:(空列)":`選択: ${id}:"${trunc(n.phrase,40)}"`;
    const path=pathToRoot(app.visual.dict,id);
    const merged=Array.from(new Set([...(app.visual.hl.pathIds||[]),...path]));
    renderVisuals(app.visual.dict,{...app.visual.hl,pathIds:merged,selId:id}, false);
  }

  function clearSelection(){
    app.visual.hl.selId=null;
    $("#selInfo").textContent="選択: -";
    renderVisuals(app.visual.dict,app.visual.hl, false);
  }

  const createNodeElement = (id, dict)=>{
    const n=dict.nodes[id];
    const g=svgElNS("g",{id:`node-${id}`, class:"node"});
    g.style.opacity="1";
    g.style.cursor="pointer";
    g.addEventListener("click",()=>setSelection(id));

    const r=id===0?18:16;
    g.appendChild(svgElNS("circle",{r}));

    const t=svgElNS("text",{"text-anchor":"middle",dy:"-2"});
    t.textContent=String(id);
    g.appendChild(t);

    const t2=svgElNS("text",{"text-anchor":"middle",dy:"11",fill:"rgba(232,236,255,.9)"});
    t2.textContent=id===0?"root":n.sym;
    g.appendChild(t2);

    const title=svgElNS("title");
    title.textContent=id===0?"0:(空列)":`${id}:"${n.phrase}"`;
    g.appendChild(title);

    graphUI.gNodes.appendChild(g);
    graphUI.nodeEls.set(id,g);
    return g;
  };

  const createEdgeElements = (childId, dict)=>{
    const line=svgElNS("line",{id:`edge-${childId}`, class:"edge"});
    const lbl=svgElNS("text",{id:`edgeLabel-${childId}`, class:"edgeLabel","text-anchor":"middle"});
    lbl.textContent=dict.nodes[childId].sym;

    graphUI.gEdges.appendChild(line);
    graphUI.gEdges.appendChild(lbl);

    graphUI.edgeEls.set(childId,line);
    graphUI.labelEls.set(childId,lbl);
    return {line,lbl};
  };

  const syncEdges = (dict)=>{
    for(let childId=1; childId<dict.nodes.length; childId++){
      const parentId=dict.nodes[childId].parent;
      const line=graphUI.edgeEls.get(childId);
      const lbl=graphUI.labelEls.get(childId);
      if(!line || !lbl) continue;

      const x1=graphUI.posX[parentId] ?? 0;
      const y1=graphUI.posY[parentId] ?? 0;
      const x2=graphUI.posX[childId] ?? x1;
      const y2=graphUI.posY[childId] ?? y1;

      line.setAttribute("x1",x1); line.setAttribute("y1",y1);
      line.setAttribute("x2",x2); line.setAttribute("y2",y2);

      const mx=(x1+x2)/2, my=(y1+y2)/2 - 6;
      lbl.setAttribute("x",mx);
      lbl.setAttribute("y",my);

      const sym=dict.nodes[childId].sym;
      if(lbl.textContent !== sym) lbl.textContent=sym;
    }
  };

  const renderGraph = (dict, hl, animateGraph)=>{
    if(!graphUI.svg) return;

    // 辞書が縮んだら（リセット等）グラフを丸ごと作り直す
    if(dict.nodes.length < graphUI.lastDictSize){
      hardResetGraph();
    }
    ensureGraphGroups();

    cancelGraphAnim();

    const {pos,width,height}=computeLayout(dict);
    graphUI.svg.setAttribute("viewBox",`0 0 ${width} ${height}`);
    graphUI.svg.setAttribute("width",String(width));
    graphUI.svg.setAttribute("height",String(height));

    const newEdgeIds=new Set();
    const nodeAnims=[];

    // ノード作成・クラス更新
    for(let id=0; id<dict.nodes.length; id++){
      let g=graphUI.nodeEls.get(id);
      const isNew = !g;
      if(!g) g=createNodeElement(id, dict);

      g.setAttribute("class", nodeClass(id, hl));

      // pos配列の確保
      if(graphUI.posX[id] == null || graphUI.posY[id] == null){
        // 新規ノードは親から出る
        let sx=pos[id].x, sy=pos[id].y;
        const p=dict.nodes[id].parent;
        if(p!=null){
          if(graphUI.posX[p]!=null && graphUI.posY[p]!=null){
            sx=graphUI.posX[p]; sy=graphUI.posY[p];
          }else{
            sx=pos[p].x; sy=pos[p].y;
          }
        }
        graphUI.posX[id]=sx;
        graphUI.posY[id]=sy;
        g.setAttribute("transform",`translate(${sx},${sy})`);
        if(isNew) g.style.opacity="0";
      }

      const sx=graphUI.posX[id], sy=graphUI.posY[id];
      const ex=pos[id].x, ey=pos[id].y;
      const moved = Math.abs(ex - sx) > 0.01 || Math.abs(ey - sy) > 0.01;

      if(animateGraph && (isNew || moved)){
        nodeAnims.push({
          id, el:g,
          sx, sy, ex, ey,
          so: isNew ? 0 : 1,
          eo: 1,
          fade: isNew
        });
      }
    }

    // エッジ作成（childIdごと）
    for(let childId=1; childId<dict.nodes.length; childId++){
      let line=graphUI.edgeEls.get(childId);
      let lbl=graphUI.labelEls.get(childId);
      if(!line || !lbl){
        const made=createEdgeElements(childId, dict);
        line=made.line; lbl=made.lbl;
        line.style.opacity="0";
        lbl.style.opacity="0";
        newEdgeIds.add(childId);
      }
    }

    // まず現状位置でエッジ同期
    syncEdges(dict);

    const finishInstant = ()=>{
      for(let id=0; id<dict.nodes.length; id++){
        const g=graphUI.nodeEls.get(id);
        const ex=pos[id].x, ey=pos[id].y;
        graphUI.posX[id]=ex;
        graphUI.posY[id]=ey;
        g.setAttribute("transform",`translate(${ex},${ey})`);
        g.style.opacity="1";
      }
      for(const childId of newEdgeIds){
        const line=graphUI.edgeEls.get(childId);
        const lbl=graphUI.labelEls.get(childId);
        if(line) line.style.opacity="1";
        if(lbl) lbl.style.opacity="1";
      }
      syncEdges(dict);
      graphUI.lastDictSize=dict.nodes.length;
    };

    if(!animateGraph || (nodeAnims.length===0 && newEdgeIds.size===0)){
      finishInstant();
      return;
    }

    graphUI.animActive=true;
    const start=performance.now();
    const step=(now)=>{
      const t=clamp((now-start)/ANIM_MS,0,1);
      const e=EASE(t);

      for(const a of nodeAnims){
        const x=a.sx + (a.ex-a.sx)*e;
        const y=a.sy + (a.ey-a.sy)*e;
        graphUI.posX[a.id]=x;
        graphUI.posY[a.id]=y;
        a.el.setAttribute("transform",`translate(${x},${y})`);
        if(a.fade){
          const op=a.so + (a.eo-a.so)*e;
          a.el.style.opacity=String(op);
        }
      }

      // エッジはノードの現在位置に追従
      syncEdges(dict);

      // 新規エッジのフェードイン
      for(const childId of newEdgeIds){
        const line=graphUI.edgeEls.get(childId);
        const lbl=graphUI.labelEls.get(childId);
        const op=String(e);
        if(line) line.style.opacity=op;
        if(lbl) lbl.style.opacity=op;
      }

      if(t<1){
        graphUI.raf=requestAnimationFrame(step);
      }else{
        // 最終値を確定
        finishInstant();
        graphUI.animActive=false;
        graphUI.raf=0;
      }
    };
    graphUI.raf=requestAnimationFrame(step);
  };

  // ===== 辞書表 =====
  const renderDictTable = (dict,hl)=>{
    const {pathIds=[],newId=null,refId=null,selId=null}=hl||{};
    const pathSet=new Set(pathIds);
    const q=($("#dictSearch").value??"").trim().toLowerCase();
    const body=$("#dictBody"); body.innerHTML="";
    for(const n of dict.nodes){
      const phrase=n.id===0?"(空列)":n.phrase;
      const parent=n.parent==null?"":String(n.parent);
      const sym=n.id===0?"":n.sym;
      const hay=`${n.id} ${parent} ${sym} ${phrase}`.toLowerCase();
      if(q && !hay.includes(q)) continue;
      let cls="d-row";
      if(pathSet.has(n.id)) cls+=" d-path";
      if(newId===n.id) cls+=" d-new";
      if(refId===n.id) cls+=" d-ref";
      if(selId===n.id) cls+=" d-sel";
      const tr=el("tr",{class:cls});
      tr.addEventListener("click",()=>setSelection(n.id));
      tr.appendChild(el("td",{text:String(n.id)}));
      tr.appendChild(el("td",{text:parent}));
      tr.appendChild(el("td",{text:sym}));
      const tdP=el("td",{text:trunc(phrase,80)}); tdP.title=phrase;
      tr.appendChild(tdP);
      body.appendChild(tr);
    }
    if(!body.firstChild){
      const tr=el("tr");
      tr.appendChild(el("td",{colspan:"4",class:"note",text:"該当なし"}));
      body.appendChild(tr);
    }
  };

  // ===== 画面更新 =====
  const renderVisuals=(dict,hl,animateGraph=false)=>{
    app.visual.dict=dict;
    app.visual.hl=hl;
    renderGraph(dict,hl,animateGraph);
    renderDictTable(dict,hl);
    updateMeta({
      step: app.mode==="encode"&&app.enc?app.enc.stepCursor:
            app.mode==="decode"&&app.dec?app.dec.stepCursor:"-",
      dictSize:dict.nodes.length
    });
  };

  // ===== ログ =====
  const resetLogTable=(msg="まだ何も実行していません。")=>{
    const body=$("#logBody"); body.innerHTML="";
    const tr=el("tr");
    tr.appendChild(el("td",{colspan:"7",class:"note",text:msg}));
    body.appendChild(tr);
  };
  const setEncodeHeader=()=>{
    $("#logHeadRow").innerHTML=`
      <th>step j</th>
      <th>処理位置</th>
      <th>w</th>
      <th>(i,c)</th>
      <th>辞書に追加</th>
      <th>備考</th>
      <th>出力進捗</th>`;
  };
  const setDecodeHeader=()=>{
    $("#logHeadRow").innerHTML=`
      <th>step j</th>
      <th>入力 (i,c)</th>
      <th>参照 w</th>
      <th>出力語</th>
      <th>辞書に追加</th>
      <th>備考</th>
      <th>出力進捗</th>`;
  };

  const renderEncodeLogs=()=>{
    const body=$("#logBody"); body.innerHTML="";
    const S=app.enc;
    if(!S || !S.logs.length){resetLogTable();return;}
    for(let i=0;i<S.logs.length;i++){
      const L=S.logs[i];
      const tr=el("tr",{class:i===S.stepCursor-1?"active":"d-row"});
      tr.appendChild(el("td",{text:String(L.step)}));
      tr.appendChild(el("td",{text:`${L.posStart}→${L.posEnd}`}));
      tr.appendChild(el("td",{text:L.matchPhrase||"(空列)"}));
      tr.appendChild(el("td",{text:L.tokenText}));
      tr.appendChild(el("td",{text:L.addedText}));
      tr.appendChild(el("td",{text:L.note||""}));
      tr.appendChild(el("td",{text:L.outputPrefix}));
      body.appendChild(tr);
    }
  };

  const renderDecodeLogs=()=>{
    const body=$("#logBody"); body.innerHTML="";
    const S=app.dec;
    if(!S || !S.logs.length){resetLogTable();return;}
    for(let i=0;i<S.logs.length;i++){
      const L=S.logs[i];
      const tr=el("tr",{class:i===S.stepCursor-1?"active":"d-row"});
      tr.appendChild(el("td",{text:String(L.step)}));
      tr.appendChild(el("td",{text:L.tokenText}));
      tr.appendChild(el("td",{text:L.refPhrase||"(空列)"}));
      tr.appendChild(el("td",{text:L.outChunk}));
      tr.appendChild(el("td",{text:L.addedText}));
      tr.appendChild(el("td",{text:L.note||""}));
      tr.appendChild(el("td",{text:L.outputPrefix}));
      body.appendChild(tr);
    }
  };

  // ===== 符号化/復号 =====
  const dictLongestMatch=(dict,input,pos0)=>{
    let nodeId=0; const path=[0]; let i=pos0;
    while(i<input.length){
      const ch=input[i];
      const child=dict.nodes[nodeId].children.get(ch);
      if(child===undefined) break;
      nodeId=child; path.push(nodeId); i++;
    }
    return {nodeId,path,nextPos:i};
  };

  const resetEncode=()=>{
    let input;
    try{ input=currentInput(); }
    catch(e){ toast(e.message,"danger"); return false; }
    if(!input.length){toast("入力が空です","danger");return false;}

    setMode("encode");
    setEncodeHeader();
    app.enc={input,pos:0,dict:newDict(),logs:[],tokens:[],stepCursor:0,done:false};
    app.dec=null;

    $("#decodedText").value="";
    $("#tokensText").value="";
    $("#bitsText").value="";

    renderVisuals(app.enc.dict,{pathIds:[],newId:null,refId:null,selId:null}, false);
    resetLogTable("符号化を開始できます。");
    setControls({nextEnabled:true,resetEnabled:true});
    setStatus("符号化モード");
    return true;
  };

  const encodeOneStep=(animateGraph=true)=>{
    const S=app.enc;
    if(!S || S.done) return;

    const dict=S.dict, input=S.input, n=input.length;
    const pos0=S.pos;
    const {nodeId,path,nextPos}=dictLongestMatch(dict,input,pos0);
    const matchPhrase=dict.nodes[nodeId].phrase;
    const nextSym=nextPos<n?input[nextPos]:null;

    let token,addedId=null,addedText="(なし)",note="";
    if(nextSym==null){
      token={index:nodeId,next:null};
      S.pos=n; S.done=true;
      note="末尾なので (i) のみ";
    }else{
      token={index:nodeId,next:nextSym};
      addedId=dictAdd(dict,nodeId,nextSym);
      addedText=`${addedId}: "${dict.nodes[addedId].phrase}"`;
      S.pos=nextPos+1;
    }

    S.tokens.push(token);
    S.stepCursor++;

    const tokenText=token.next==null?`(${token.index})`:`(${token.index}, ${token.next})`;
    const prefix=S.input.slice(0,S.pos).join("");

    S.logs.push({
      step:S.stepCursor,
      posStart:pos0,
      posEnd:S.pos,
      matchPhrase,
      nextSym,
      tokenText,
      addedText,
      note,
      outputPrefix:prefix
    });

    $("#tokensText").value=formatTokens(S.tokens);
    renderEncodeLogs();
    renderVisuals(dict,{pathIds:path,newId:addedId,refId:token.index,selId:app.visual.hl.selId}, animateGraph);
    updateBitsView();

    if(S.done){
      setControls({nextEnabled:false,resetEnabled:true});
      setStatus("符号化完了");
      toast("符号化が完了しました","good");
    }
  };

  const encodeAll=()=>{
    if(!resetEncode()) return;
    while(app.enc && !app.enc.done){
      encodeOneStep(false); // 全部は即時更新（アニメなし）
      if(app.enc.stepCursor>1000){toast("ステップ数が多すぎるので停止しました","danger");break;}
    }
  };

  const resetDecode=()=>{
    let toks;
    try{ toks=parseTokens($("#tokensText").value); }
    catch(e){ toast(e.message,"danger"); return false; }
    if(!toks.length){toast("符号語列が空です","danger");return false;}

    setMode("decode");
    setDecodeHeader();
    app.dec={tokens:toks,idx:0,dict:newDict(),out:[],logs:[],stepCursor:0,done:false};
    app.enc=null;

    $("#decodedText").value="";

    renderVisuals(app.dec.dict,{pathIds:[],newId:null,refId:null,selId:null}, false);
    resetLogTable("復号を開始できます。");
    setControls({nextEnabled:true,resetEnabled:true});
    setStatus("復号モード");
    updateBitsView();
    return true;
  };

  const decodeOneStep=(animateGraph=true)=>{
    const S=app.dec;
    if(!S || S.done) return;

    if(S.idx>=S.tokens.length){
      S.done=true;
      setControls({nextEnabled:false,resetEnabled:true});
      setStatus("復号完了");
      toast("復号が完了しました","good");
      return;
    }

    const dict=S.dict, tok=S.tokens[S.idx];
    if(tok.index<0 || tok.index>=dict.nodes.length){
      toast(`参照番号 ${tok.index} が辞書サイズ ${dict.nodes.length} を超えています`,"danger");
      S.done=true;
      setControls({nextEnabled:false,resetEnabled:true});
      return;
    }

    const refPhrase=dict.nodes[tok.index].phrase;
    let outChunk,addedId=null,addedText="(なし)",note="";
    if(tok.next==null){
      outChunk=refPhrase;
      note="末尾なので (i) のみ";
      S.idx++; S.stepCursor++;
    }else{
      outChunk=refPhrase+tok.next;
      addedId=dictAdd(dict,tok.index,tok.next);
      addedText=`${addedId}: "${dict.nodes[addedId].phrase}"`;
      S.idx++; S.stepCursor++;
    }

    S.out.push(outChunk);

    const tokenText=tok.next==null?`(${tok.index})`:`(${tok.index}, ${tok.next})`;
    const prefix=S.out.join("");

    S.logs.push({
      step:S.stepCursor,
      tokenText,
      refPhrase,
      outChunk,
      addedText,
      note,
      outputPrefix:prefix
    });

    $("#decodedText").value=prefix;
    renderDecodeLogs();
    renderVisuals(dict,{pathIds:[],newId:addedId,refId:tok.index,selId:app.visual.hl.selId}, animateGraph);
    updateBitsView();

    if(S.idx>=S.tokens.length){
      S.done=true;
      setControls({nextEnabled:false,resetEnabled:true});
      setStatus("復号完了");
      toast("復号が完了しました","good");
    }
  };

  const decodeAll=()=>{
    if(!resetDecode()) return;
    while(app.dec && !app.dec.done){
      decodeOneStep(false); // 全部は即時更新（アニメなし）
      if(app.dec.stepCursor>1000){toast("ステップ数が多すぎるので停止しました","danger");break;}
    }
  };

  // ===== 付随操作 =====
  const setExample=()=>{
    $("#inputText").value="ababbababaa";
    renderParseInfo();
    toast("例を入力しました","good");
  };
  const randomInput=()=>{
    const A=currentAlphabet();
    if(!A.length){toast("アルファベット Σ が空です","danger");return;}
    const len=clamp(Number($("#randLen").value||24),1,400);
    let s=""; for(let i=0;i<len;i++) s+=A[Math.floor(Math.random()*A.length)];
    $("#inputText").value=s;
    renderParseInfo();
    toast("ランダム入力を生成しました","good");
  };

  const copyTextFrom=async(text)=>{
    if(!text){toast("空です","danger");return;}
    try{await navigator.clipboard.writeText(text);toast("コピーしました","good");}
    catch{toast("コピーに失敗しました（手動でコピーしてください）","danger");}
  };

  const resetCurrentMode=()=>{
    if(app.mode==="encode") resetEncode();
    else if(app.mode==="decode") resetDecode();
    else toast("リセットできるモードがありません","danger");
  };

  const clearAll=()=>{
    app.mode="idle";
    app.enc=null; app.dec=null;
    app.visual={dict:newDict(),hl:{pathIds:[],newId:null,refId:null,selId:null}};
    $("#inputText").value="ababbababaa";
    $("#tokensText").value="";
    $("#bitsText").value="";
    $("#decodedText").value="";
    $("#dictSearch").value="";
    $("#selInfo").textContent="選択: -";
    setEncodeHeader();
    resetLogTable();
    renderVisuals(app.visual.dict,app.visual.hl,false);
    setControls({nextEnabled:false,resetEnabled:false});
    setStatus("準備OK");
    renderParseInfo();
  };

  const exportSvg=()=>{
    const svg=$("#graph");
    const xml=new XMLSerializer().serializeToString(svg);
    const blob=new Blob([xml],{type:"image/svg+xml;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=el("a",{href:url,download:"lz78_dictionary.svg"});
    document.body.appendChild(a);a.click();a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),500);
    toast("SVG を保存しました","good");
  };

  const exportDictCsv=()=>{
    const dict=app.visual.dict;
    const rows=[["id","parent","sym","phrase"]];
    for(const n of dict.nodes){
      rows.push([String(n.id),n.parent==null?"":String(n.parent),n.sym,n.phrase]);
    }
    const csv=rows.map(r=>r.map(c=>{
      const s=String(c??"");return /[",\n\r]/.test(s)?`"${s.replace(/"/g,'""')}"`:s;
    }).join(",")).join("\n");
    const blob=new Blob(["\ufeff"+csv],{type:"text/csv;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=el("a",{href:url,download:"lz78_dictionary.csv"});
    document.body.appendChild(a);a.click();a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),500);
    toast("辞書CSVを保存しました","good");
  };

  // ===== 起動 =====
  window.addEventListener("load",()=>{
    graphUI.svg=$("#graph");

    setEncodeHeader();
    renderVisuals(app.visual.dict,app.visual.hl,false);
    setControls({nextEnabled:false,resetEnabled:false});
    renderParseInfo();
    setStatus("準備OK");

    $("#btnEncodeAll").addEventListener("click",encodeAll);
    $("#btnEncodeStep").addEventListener("click",()=>{ if(resetEncode()) toast("符号化ステップ開始（次へでアニメ）","good"); });
    $("#btnDecodeAll").addEventListener("click",decodeAll);
    $("#btnDecodeStep").addEventListener("click",()=>{ if(resetDecode()) toast("復号ステップ開始（次へでアニメ）","good"); });

    $("#btnNext").addEventListener("click",()=>{
      if(app.mode==="encode") encodeOneStep(true);
      else if(app.mode==="decode") decodeOneStep(true);
      else toast("まず符号化/復号を開始してください","danger");
    });

    $("#btnReset").addEventListener("click",resetCurrentMode);
    $("#btnClearAll").addEventListener("click",clearAll);

    $("#btnExample").addEventListener("click",setExample);
    $("#btnRandom").addEventListener("click",randomInput);
    $("#btnCopyTokens").addEventListener("click",()=>copyTextFrom($("#tokensText").value));
    $("#btnCopyBits").addEventListener("click",()=>copyTextFrom($("#bitsText").value));

    $("#btnFit").addEventListener("click",()=>{
      // スクロール方式なので、ここでは再描画で整形
      renderVisuals(app.visual.dict, app.visual.hl, false);
      toast("再レイアウトしました（スクロールで確認）","good");
    });
    $("#btnExportSvg").addEventListener("click",exportSvg);
    $("#btnExportDict").addEventListener("click",exportDictCsv);
    $("#btnClearSel").addEventListener("click",clearSelection);

    $("#dictSearch").addEventListener("input",()=>renderDictTable(app.visual.dict,app.visual.hl));
    $("#alphabet").addEventListener("input",renderParseInfo);
    $("#inputText").addEventListener("input",renderParseInfo);
    $("#tokensText").addEventListener("input",updateBitsView);
    $("#bitsStyle").addEventListener("change",updateBitsView);

    document.addEventListener("keydown",e=>{
      if(e.key==="Enter" && (e.ctrlKey||e.metaKey)){
        const active=document.activeElement;
        if(active===$("#tokensText")) decodeAll();
        else encodeAll();
      }
      if(e.key===" " && (e.ctrlKey||e.metaKey)){
        e.preventDefault();
        if(!$("#btnNext").disabled) $("#btnNext").click();
      }
    });
  });
})();
</script>
</body>
</html>
